/*
Copyright 2016 BitTorrent Inc

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#ifndef SCOUT_HPP
# define SCOUT_HPP

#include <vector>
#include <array>
#include <cstdint>
#include <functional>
#include <span.h>
#include <dht.h>

namespace scout
{

using secret_key = std::array<gsl::byte, 32>;
using secret_key_span = gsl::span<gsl::byte, 32>;
using csecret_key_span = gsl::span<gsl::byte const, 32>;
using public_key = std::array<gsl::byte, 32>;
using public_key_span = gsl::span<gsl::byte, 32>;
using cpublic_key_span = gsl::span<gsl::byte const, 32>;
using hash = std::array<gsl::byte, 20>;
using hash_span = gsl::span<gsl::byte, 20>;
using chash_span = gsl::span<gsl::byte const, 20>;

// a mutable blob of data
// each entry has an id associated with it which must be unique among the entries it is stored with
class entry
{
public:
	entry(uint32_t id) : m_seq(0), m_id(id) {}

	static std::pair<entry, gsl::span<gsl::byte const>> parse(gsl::span<gsl::byte const> input);
	gsl::span<gsl::byte> serialize(gsl::span<gsl::byte> output) const;

	uint32_t id() const { return m_id; }
	std::vector<gsl::byte> const& value() const { return m_contents; }
	void assign(gsl::span<gsl::byte const> contents)
	{
		m_contents.assign(contents.begin(), contents.end());
		++m_seq;
	}

	// convenience function to save callers from having to do an
	// explicit to_bytes
	template <typename U, std::ptrdiff_t... Dimensions>
	void assign(gsl::span<U, Dimensions...> s)
	{
		assign(gsl::as_bytes(s));
	}

	bool operator==(entry const& o) const
	{
		return m_id == o.m_id
			&& m_seq == o.m_seq
			&& m_contents == o.m_contents;
	}

	entry& operator=(entry o)
	{
		m_id = o.m_id;
		m_seq = o.m_seq;
		m_contents = o.m_contents;
		return *this;
	}

	// for internal use:
	int64_t seq() const { return m_seq; }
	void update_seq(int64_t seq) { m_seq = seq; }
	void update_contents(std::vector<gsl::byte> contents) { m_contents = contents; }

private:
	entry(int64_t seq, uint32_t id, std::vector<gsl::byte> content)
		: m_contents(std::move(content)), m_seq(seq), m_id(id) {}

	std::vector<gsl::byte> m_contents;
	int64_t m_seq;
	uint32_t m_id;
};

// a token is associated with each piece of immutable data stored in a list
// it should be stored alongside the data and passed along with it to put
class list_token
{
public:
	friend class list_head;

	// input span must be extactly the size of the serialized token
	static list_token parse(gsl::span<gsl::byte const> input);
	gsl::span<gsl::byte> serialize(gsl::span<gsl::byte> output) const;

	hash const& next() const { return m_next; }

	bool operator==(list_token const& o) const
	{
		return m_next == o.m_next;
	}

private:
	list_token(hash next) : m_next(next) {}

	hash m_next;
};

// The head of a linked-list stored in the DHT. New items can only be inserted
// at the head of the list and list can only be retrieved starting at the head (LIFO).
class list_head
{
public:
	list_head()
	{
		m_head.fill(gsl::byte(0));
	}

	// input span must be extactly the size of the serialized list head
	static list_head parse(gsl::span<gsl::byte const> input);
	gsl::span<gsl::byte> serialize(gsl::span<gsl::byte> output) const;

	// add an item to the linked-list
	// the returned list_token should be stored with the contents and passed to put()
	list_token push_front(gsl::span<gsl::byte const> contents);

	// get the hash of the head of the list
	// this can be passed to get() to retrieve the first item in the list
	hash const& head() const { return m_head; }

	bool operator==(list_head const& o) const
	{
		return m_head == o.m_head;
	}

private:
	list_head(hash head) : m_head(head) {}

	hash m_head;
};

// generate a new, random key pair
std::pair<secret_key, public_key> generate_keypair();

// do an ECDH key exchange
secret_key key_exchange(csecret_key_span sk, cpublic_key_span pk);

// takes a span of entries and write them out to a buffer
// returns a new span pointing to to one past the last byte used to store
// the entries
gsl::span<gsl::byte> serialize(gsl::span<entry const> entries, gsl::span<gsl::byte> output);

// parse a list of entries as generated by serialize()
// returns a span starting at one past the last byte used to store the entries
gsl::span<gsl::byte const> parse(gsl::span<gsl::byte const> input, std::vector<entry>& entries);

// called when a new or updated entry is received from the DHT
using entry_updated = std::function<void(entry const& e)>;
// called just before the list of entries is stored in the DHT
using finalize_entries = std::function<void(std::vector<entry>& entries)>;
// called when storing the current entry list has completed
using sync_finished = std::function<void()>;
// called when the value associated with the hash has been received
// the DHT transaction ends after this function is called
// if no value is found an empty span will be passed
using item_received = std::function<void(std::vector<gsl::byte> contents, hash const& next_hash)>;
// called when a put has completed
using put_finished = std::function<void()>;

// Synchronize a list of entries with the DHT. First entries are read from the
// DHT then an updated list is written back.
//
// entry_cb will be called for any entries retrived from the DHT which are not in
// the passed in entries vector or are newer than the entry found there
//
// finalize_cb will be called once the get operation has completed. It is passed a vector
// containing the passed in entries merged with any new or updated entries retrived from the DHT.
// The finalize_cb provides a final opportunity to modify the list of entries before it is written.
//
// All entries in the vector passed to finalize_cb are written to the DHT. Once the put operation
// is complete finished_cb is invoked
void synchronize(IDht& dht, secret_key_span shared_key, std::vector<entry> const& entries
	, entry_updated entry_cb, finalize_entries finalize_cb, sync_finished finished_cb);

// store an immutable item in the DHT
//
// the token must be a value returned from list_head::push_front called with
// the contents
//
// finished_cb will be called once the put operation has completed
void put(IDht& dht, list_token const& token, gsl::span<gsl::byte const> contents
	, put_finished finished_cb);

// retrieve an immutable item from the DHT identified by the given hash
//
// received_cb will be called with the message contents and the hash of the next
// message in the list
//
// the next hash will be all zeros if it is the last message in the list
// if the message is not found then received_cb will be called with empty contents
void get(IDht& dht, chash_span address, item_received received_cb);

}

#endif
